name: Validate Datapack (Complete)

on:
  pull_request:
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  push:
    branches:
      - main
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  workflow_dispatch:

env:
  STRICT_MODE: false  # true = unknown commands fail, false = warnings only
  TARGET: release     # release | snapshot
  SECURITY_CHECK: true  # Enable security scanning
  PERFORMANCE_CHECK: true  # Enable performance analysis

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq tree bc python3
          echo "âœ… Dependencies installed"

      - name: Setup Python Validator
        run: |
          cat > /tmp/validator.py << 'VALIDATOR_EOF'
#!/usr/bin/env python3
"""
Minecraft Command Validator - Enhanced Version
Validates .mcfunction files for security threats and suspicious patterns
"""

import re
import json
import sys
from typing import List, Dict, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path

@dataclass
class Finding:
    """Security finding"""
    line_number: int
    severity: str  # CRITICAL, WARNING, INFO
    category: str
    message: str
    command: str
    pattern: str = ""
    
    def to_dict(self):
        return asdict(self)

class CommandValidator:
    """Enhanced Minecraft command security validator"""
    
    # Emoji mapping
    EMOJI = {
        'CRITICAL': 'ğŸš¨',
        'WARNING': 'âš ï¸',
        'INFO': 'â„¹ï¸',
        'SAFE': 'âœ…'
    }
    
    # Kritik tehlikeli komutlar
    CRITICAL_PATTERNS = {
        r'/op\s+': 'Grants operator privileges',
        r'/deop\s+@a': 'Removes all operator privileges',
        r'/stop': 'Stops the server',
        r'/restart': 'Restarts the server',
        r'/whitelist\s+off': 'Disables whitelist protection',
        r'/ban-ip\s+': 'IP ban command',
        r'/pardon-ip\s+': 'Removes IP ban',
        r'/execute\s+.*run\s+rm\s+-rf': 'Dangerous file deletion',
        r'/transfer\s+': 'Player transfer (potential redirect)',
        r'open_url.*://': 'External URL (phishing risk)',
    }
    
    # ÅÃ¼pheli patternler
    SUSPICIOUS_PATTERNS = {
        r'clickEvent.*run_command': 'Interactive book/sign command',
        r'/give.*written_book': 'Gives clickable book',
        r'/gamemode\s+(creative|spectator)': 'Changes gamemode',
        r'/tp\s+@[aps]\s+[~-]?\d+': 'Teleportation command',
        r'/function\s+.*:.*': 'Function call (verify source)',
        r'/data\s+merge': 'Data manipulation',
        r'/execute\s+as\s+@[ae]': 'Execute as all entities/players',
        r'/clear\s+@a': 'Clears all player inventories',
        r'/kill\s+@[ae]': 'Kills entities/players',
    }
    
    # Backdoor indicators
    BACKDOOR_INDICATORS = {
        r'author.*[Hh]acker': 'Suspicious author name',
        r'author.*[Rr]oot': 'Suspicious author name',
        r'author.*[Aa]dmin.*[Pp]anel': 'Suspicious title pattern',
        r'title.*[Ss]ecret': 'Hidden functionality indicator',
        r'title.*[Hh]idden': 'Hidden functionality indicator',
        r'clickEvent.*value.*op': 'OP grant via click',
        r'clickEvent.*value.*gamemode': 'Gamemode change via click',
    }
    
    # URL patterns
    URL_PATTERNS = {
        r'http://[^"\']+': 'Unencrypted HTTP URL',
        r'https?://[^/]*\.tk[/"\']': 'Free domain (phishing risk)',
        r'https?://[^/]*\.ml[/"\']': 'Free domain (phishing risk)',
        r'https?://[^/]*\.ga[/"\']': 'Free domain (phishing risk)',
        r'open_url': 'URL click action',
    }
    
    # JavaScript/Injection patterns
    INJECTION_PATTERNS = {
        r'<script': 'JavaScript injection attempt',
        r'javascript:': 'JavaScript protocol',
        r'onerror\s*=': 'JavaScript event handler',
        r'eval\s*\(': 'Code evaluation',
        r'{{.*}}': 'Template injection pattern',
    }
    
    def __init__(self):
        self.findings: List[Finding] = []
        self.stats = {
            'total_lines': 0,
            'command_lines': 0,
            'critical': 0,
            'warnings': 0,
            'info': 0
        }
    
    def validate_line(self, line: str, line_num: int) -> List[Finding]:
        """Validate a single line and return findings"""
        findings = []
        
        # Skip comments and empty lines
        if not line.strip() or line.strip().startswith('#'):
            return findings
        
        self.stats['command_lines'] += 1
        
        # Check critical patterns
        for pattern, desc in self.CRITICAL_PATTERNS.items():
            if re.search(pattern, line, re.IGNORECASE):
                findings.append(Finding(
                    line_number=line_num,
                    severity='CRITICAL',
                    category='dangerous_command',
                    message=f'CRITICAL - {desc}',
                    command=line.strip(),
                    pattern=pattern
                ))
                self.stats['critical'] += 1
        
        # Check backdoor indicators
        for pattern, desc in self.BACKDOOR_INDICATORS.items():
            if re.search(pattern, line, re.IGNORECASE):
                findings.append(Finding(
                    line_number=line_num,
                    severity='CRITICAL',
                    category='backdoor',
                    message=f'BACKDOOR - {desc}',
                    command=line.strip(),
                    pattern=pattern
                ))
                self.stats['critical'] += 1
        
        # Check URL patterns
        for pattern, desc in self.URL_PATTERNS.items():
            if re.search(pattern, line, re.IGNORECASE):
                findings.append(Finding(
                    line_number=line_num,
                    severity='CRITICAL',
                    category='phishing',
                    message=f'PHISHING RISK - {desc}',
                    command=line.strip(),
                    pattern=pattern
                ))
                self.stats['critical'] += 1
        
        # Check injection patterns
        for pattern, desc in self.INJECTION_PATTERNS.items():
            if re.search(pattern, line, re.IGNORECASE):
                findings.append(Finding(
                    line_number=line_num,
                    severity='CRITICAL',
                    category='injection',
                    message=f'INJECTION - {desc}',
                    command=line.strip(),
                    pattern=pattern
                ))
                self.stats['critical'] += 1
        
        # Check suspicious patterns (if no critical found)
        if not findings:
            for pattern, desc in self.SUSPICIOUS_PATTERNS.items():
                if re.search(pattern, line, re.IGNORECASE):
                    findings.append(Finding(
                        line_number=line_num,
                        severity='WARNING',
                        category='suspicious',
                        message=f'{desc} - verify legitimacy',
                        command=line.strip(),
                        pattern=pattern
                    ))
                    self.stats['warnings'] += 1
                    break
        
        # Check for book menus without clickEvents (safe)
        if 'written_book' in line and 'clickEvent' not in line:
            findings.append(Finding(
                line_number=line_num,
                severity='INFO',
                category='safe',
                message='Book menu (no clickEvents)',
                command=line.strip()[:80] + '...' if len(line) > 80 else line.strip()
            ))
            self.stats['info'] += 1
        
        return findings
    
    def validate_file(self, filepath: str) -> Dict:
        """Validate entire file"""
        self.findings = []
        
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except Exception as e:
            return {'error': f'Failed to read file: {e}'}
        
        self.stats['total_lines'] = len(lines)
        
        for i, line in enumerate(lines, 1):
            findings = self.validate_line(line, i)
            self.findings.extend(findings)
        
        return self.generate_report()
    
    def generate_report(self) -> Dict:
        """Generate comprehensive report"""
        report = {
            'summary': {
                'total_lines': self.stats['total_lines'],
                'command_lines': self.stats['command_lines'],
                'total_findings': len(self.findings),
                'critical': self.stats['critical'],
                'warnings': self.stats['warnings'],
                'info': self.stats['info'],
                'risk_level': self.calculate_risk_level()
            },
            'findings': [f.to_dict() for f in self.findings],
            'findings_by_category': self.group_by_category(),
            'findings_by_severity': self.group_by_severity()
        }
        return report
    
    def calculate_risk_level(self) -> str:
        """Calculate overall risk level"""
        if self.stats['critical'] > 0:
            return 'HIGH'
        elif self.stats['warnings'] > 3:
            return 'MEDIUM'
        elif self.stats['warnings'] > 0:
            return 'LOW'
        return 'SAFE'
    
    def group_by_category(self) -> Dict:
        """Group findings by category"""
        categories = {}
        for finding in self.findings:
            cat = finding.category
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(finding.to_dict())
        return categories
    
    def group_by_severity(self) -> Dict:
        """Group findings by severity"""
        severities = {'CRITICAL': [], 'WARNING': [], 'INFO': []}
        for finding in self.findings:
            severities[finding.severity].append(finding.to_dict())
        return severities
    
    def print_console_report(self):
        """Print human-readable console report"""
        print("\n" + "="*70)
        print("ğŸ›¡ï¸  MINECRAFT COMMAND VALIDATOR - SECURITY REPORT")
        print("="*70)
        
        # Summary
        print(f"\nğŸ“Š SUMMARY:")
        print(f"   Total Lines: {self.stats['total_lines']}")
        print(f"   Command Lines: {self.stats['command_lines']}")
        print(f"   Total Findings: {len(self.findings)}")
        print(f"   ğŸš¨ Critical: {self.stats['critical']}")
        print(f"   âš ï¸  Warnings: {self.stats['warnings']}")
        print(f"   â„¹ï¸  Info: {self.stats['info']}")
        print(f"   Risk Level: {self.calculate_risk_level()}")
        
        # Findings
        if self.findings:
            print(f"\nğŸ” DETAILED FINDINGS:\n")
            
            # Critical first
            critical = [f for f in self.findings if f.severity == 'CRITICAL']
            if critical:
                print("ğŸš¨ CRITICAL ISSUES:")
                for finding in critical:
                    print(f"   Line {finding.line_number}: {finding.message}")
                    print(f"   â†’ {finding.command[:100]}")
                    if finding.pattern:
                        print(f"   Pattern: {finding.pattern}")
                    print()
            
            # Then warnings
            warnings = [f for f in self.findings if f.severity == 'WARNING']
            if warnings:
                print("âš ï¸  WARNINGS:")
                for finding in warnings:
                    print(f"   Line {finding.line_number}: {finding.message}")
                    print(f"   â†’ {finding.command[:100]}")
                    print()
            
            # Info last
            info = [f for f in self.findings if f.severity == 'INFO']
            if info:
                print("â„¹ï¸  INFORMATIONAL:")
                for finding in info[:5]:
                    print(f"   Line {finding.line_number}: {finding.message}")
                if len(info) > 5:
                    print(f"   ... and {len(info) - 5} more")
                print()
        
        print("="*70)
        
        # Recommendations
        if self.stats['critical'] > 0:
            print("\nâ›” RECOMMENDATION: DO NOT USE THIS FILE!")
            print("   Contains critical security issues that could compromise your server.")
        elif self.stats['warnings'] > 0:
            print("\nâš ï¸  RECOMMENDATION: Review carefully before use")
            print("   Contains suspicious patterns that need verification.")
        else:
            print("\nâœ… RECOMMENDATION: File appears safe to use")
        
        print()

def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python validator.py <file.mcfunction> [--json]")
        sys.exit(1)
    
    filepath = sys.argv[1]
    json_output = '--json' in sys.argv
    
    if not Path(filepath).exists():
        print(f"Error: File not found: {filepath}")
        sys.exit(1)
    
    validator = CommandValidator()
    report = validator.validate_file(filepath)
    
    if 'error' in report:
        print(f"Error: {report['error']}")
        sys.exit(1)
    
    if json_output:
        print(json.dumps(report, indent=2))
    else:
        validator.print_console_report()
    
    sys.exit(1 if report['summary']['critical'] > 0 else 0)

if __name__ == '__main__':
    main()
VALIDATOR_EOF
          
          chmod +x /tmp/validator.py
          echo "âœ… Python validator created"

      - name: Validate Datapack (All Checks)
        id: validation
        run: |
          set -e
          
          TOTAL_ERRORS=0
          TOTAL_WARNINGS=0
          SECURITY_ISSUES=0
          PERFORMANCE_ISSUES=0
          
          # Valid pack formats for Minecraft 1.21+
          VALID_FORMATS=(48 81 88 94)
          INVALID_THRESHOLD=47
          
          # Create directories
          mkdir -p /tmp/pack_formats
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ DATAPACK VALIDATION STARTED (Minecraft 1.21+)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 1. JSON SYNTAX VALIDATION
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” [1/8] Validating JSON Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          json_error=0
          json_count=0
          failed_files=()
          
          while IFS= read -r -d $'\0' file; do
            json_count=$((json_count + 1))
            if ! jq empty "$file" 2>/dev/null; then
              echo "  âŒ Invalid JSON: $file"
              failed_files+=("$file")
              json_error=1
            fi
          done < <(find new_versions -name "*.json" -type f -print0 2>/dev/null || true)
          
          if [ $json_error -eq 0 ]; then
            echo "  âœ… All $json_count JSON files are valid"
          else
            echo "  âŒ Failed: ${#failed_files[@]} file(s)"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          fi
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 2. PACK.MCMETA VALIDATION
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ [2/8] Validating pack.mcmeta..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          mcmeta_error=0
          mcmeta_warnings=0
          mcmeta_count=0
          
          while IFS= read -r -d $'\0' file; do
            mcmeta_count=$((mcmeta_count + 1))
            datapack_root=$(dirname "$file")
            datapack_id=$(echo "$datapack_root" | md5sum | cut -d' ' -f1)
            
            echo "  ğŸ“¦ $file"
            
            if ! jq -e '.pack.pack_format' "$file" > /dev/null 2>&1; then
              echo "     âŒ Missing pack.pack_format"
              mcmeta_error=1
              continue
            fi
            
            pack_format=$(jq -r '.pack.pack_format' "$file")
            echo "$pack_format:$datapack_root" > "/tmp/pack_formats/${datapack_id}.txt"
            
            is_valid=0
            for valid_format in "${VALID_FORMATS[@]}"; do
              if [ "$pack_format" -eq "$valid_format" ] 2>/dev/null; then
                is_valid=1
                break
              fi
            done
            
            if [ $is_valid -eq 1 ]; then
              echo "     âœ… Pack format: $pack_format"
            elif [ "$pack_format" -le "$INVALID_THRESHOLD" ] 2>/dev/null; then
              echo "     âŒ Invalid pack_format $pack_format (must be 48, 81, 88, or 94)"
              mcmeta_error=1
            else
              echo "     âš ï¸  Unknown pack_format: $pack_format"
              mcmeta_warnings=$((mcmeta_warnings + 1))
            fi
            
            if ! jq -e '.pack.description' "$file" > /dev/null 2>&1; then
              echo "     âš ï¸  Missing pack.description (recommended)"
              mcmeta_warnings=$((mcmeta_warnings + 1))
            fi
            
          done < <(find new_versions -path "*/datapack/pack.mcmeta" -type f -print0 2>/dev/null || true)
          
          if [ $mcmeta_count -eq 0 ]; then
            echo "  âŒ No pack.mcmeta files found"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          elif [ $mcmeta_error -eq 0 ]; then
            echo "  âœ… All pack.mcmeta files valid"
            [ $mcmeta_warnings -gt 0 ] && echo "  âš ï¸  $mcmeta_warnings warning(s)"
          else
            echo "  âŒ pack.mcmeta validation failed"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          fi
          TOTAL_WARNINGS=$((TOTAL_WARNINGS + mcmeta_warnings))
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 3. DATAPACK STRUCTURE
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ [3/8] Validating Structure..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          struct_error=0
          datapack_count=0
          
          while IFS= read -r -d $'\0' file; do
            dir=$(dirname "$file")
            datapack_count=$((datapack_count + 1))
            
            if [ ! -d "$dir/data" ]; then
              echo "  âŒ Missing data/ in: $dir"
              struct_error=1
            else
              namespace_count=$(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
              echo "  âœ… Datapack: $dir ($namespace_count namespace(s))"
              
              while IFS= read -r -d $'\0' namespace; do
                ns_name=$(basename "$namespace")
                echo "     ğŸ“‚ Namespace: $ns_name"
                
                [ -d "$namespace/function" ] && echo "        âš™ï¸  functions/"
                [ -d "$namespace/advancement" ] && echo "        ğŸ† advancements/"
                [ -d "$namespace/loot_table" ] && echo "        ğŸ loot_tables/"
                [ -d "$namespace/recipe" ] && echo "        ğŸ“œ recipes/"
                [ -d "$namespace/predicate" ] && echo "        ğŸ” predicates/"
                [ -d "$namespace/tag" ] && echo "        ğŸ·ï¸  tags/"
                [ -d "$namespace/structure" ] && echo "        ğŸ—ï¸  structures/"
                [ -d "$namespace/worldgen" ] && echo "        ğŸŒ worldgen/"
                [ -d "$namespace/item_modifier" ] && echo "        âœ¨ item_modifiers/"
                [ -d "$namespace/chat_type" ] && echo "        ğŸ’¬ chat_types/"
                [ -d "$namespace/damage_type" ] && echo "        âš”ï¸  damage_types/"
                [ -d "$namespace/enchantment" ] && echo "        âœ¨ enchantments/"
                [ -d "$namespace/jukebox_song" ] && echo "        ğŸµ jukebox_songs/"
                
              done < <(find "$dir/data" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null || true)
            fi
          done < <(find new_versions -path "*/datapack/pack.mcmeta" -type f -print0 2>/dev/null || true)
          
          if [ $struct_error -eq 0 ]; then
            echo "  âœ… Structure validation passed"
          else
            echo "  âŒ Structure validation failed"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          fi
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 4. FUNCTION FILES VALIDATION (COMPREHENSIVE)
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âš™ï¸  [4/8] Validating Functions..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          func_error=0
          func_warnings=0
          total_funcs=0
          total_commands=0
          
          # â˜… COMPREHENSIVE Command compatibility matrix (ALL MINECRAFT COMMANDS)
          declare -A command_min_format
          
          # Basic commands (1.13+, pack_format 1+)
          command_min_format["say"]=1
          command_min_format["tellraw"]=1
          command_min_format["tell"]=1
          command_min_format["msg"]=1
          command_min_format["w"]=1
          command_min_format["me"]=1
          command_min_format["execute"]=1
          command_min_format["scoreboard"]=1
          command_min_format["function"]=1
          command_min_format["gamemode"]=1
          command_min_format["give"]=1
          command_min_format["kill"]=1
          command_min_format["summon"]=1
          command_min_format["tp"]=1
          command_min_format["teleport"]=1
          command_min_format["time"]=1
          command_min_format["weather"]=1
          command_min_format["fill"]=1
          command_min_format["setblock"]=1
          command_min_format["clone"]=1
          command_min_format["playsound"]=1
          command_min_format["stopsound"]=1
          command_min_format["particle"]=1
          command_min_format["effect"]=1
          command_min_format["enchant"]=1
          command_min_format["xp"]=1
          command_min_format["experience"]=1
          command_min_format["clear"]=1
          command_min_format["tag"]=1
          command_min_format["team"]=1
          command_min_format["title"]=1
          command_min_format["trigger"]=1
          command_min_format["attribute"]=1
          command_min_format["bossbar"]=1
          command_min_format["data"]=1
          command_min_format["datapack"]=1
          command_min_format["worldborder"]=1
          command_min_format["schedule"]=1
          command_min_format["forceload"]=1
          command_min_format["locate"]=1
          command_min_format["spectate"]=1
          command_min_format["spawnpoint"]=1
          command_min_format["setworldspawn"]=1
          command_min_format["difficulty"]=1
          command_min_format["gamerule"]=1
          command_min_format["advancement"]=1
          command_min_format["recipe"]=1
          command_min_format["reload"]=1
          command_min_format["seed"]=1
          command_min_format["defaultgamemode"]=1
          command_min_format["list"]=1
          command_min_format["help"]=1
          command_min_format["ban"]=1
          command_min_format["ban-ip"]=1
          command_min_format["banlist"]=1
          command_min_format["pardon"]=1
          command_min_format["pardon-ip"]=1
          command_min_format["kick"]=1
          command_min_format["op"]=1
          command_min_format["deop"]=1
          command_min_format["whitelist"]=1
          command_min_format["save-all"]=1
          command_min_format["save-on"]=1
          command_min_format["save-off"]=1
          command_min_format["stop"]=1
          command_min_format["publish"]=1
          command_min_format["debug"]=1
          command_min_format["perf"]=1
          command_min_format["jfr"]=1
          command_min_format["loot"]=1
          command_min_format["fillbiome"]=1
          command_min_format["place"]=1
          command_min_format["jukebox"]=1
          command_min_format["spreadplayers"]=1
          
          # 1.20.2+ commands (pack_format 18+, mapping to 81)
          command_min_format["item"]=81
          command_min_format["damage"]=81
          command_min_format["ride"]=81
          command_min_format["return"]=81
          command_min_format["tick"]=81
          command_min_format["random"]=81
          
          # 1.21+ commands (pack_format 48+)
          command_min_format["transfer"]=48
          command_min_format["dialog"]=48
          
          # Deprecated commands
          declare -A deprecated_commands
          deprecated_commands["replaceitem"]="Use /item replace (requires pack_format 81+)"
          deprecated_commands["locatebiome"]="Use /locate biome (1.19+)"
          
          # â˜… COMPREHENSIVE Execute subcommands (ALL VARIANTS)
          declare -A execute_subcommands
          
          # Basic subcommands (1.13+)
          execute_subcommands["as "]=1
          execute_subcommands["at "]=1
          execute_subcommands["positioned "]=1
          execute_subcommands["rotated "]=1
          execute_subcommands["facing "]=1
          execute_subcommands["align "]=1
          execute_subcommands["anchored "]=1
          execute_subcommands["in "]=1
          execute_subcommands["if "]=1
          execute_subcommands["unless "]=1
          execute_subcommands["store "]=1
          execute_subcommands["run "]=1
          
          # Execute conditions (1.13+)
          execute_subcommands["if block "]=1
          execute_subcommands["unless block "]=1
          execute_subcommands["if blocks "]=1
          execute_subcommands["unless blocks "]=1
          execute_subcommands["if entity "]=1
          execute_subcommands["unless entity "]=1
          execute_subcommands["if score "]=1
          execute_subcommands["unless score "]=1
          execute_subcommands["if predicate "]=1
          execute_subcommands["unless predicate "]=1
          execute_subcommands["if data "]=1
          execute_subcommands["unless data "]=1
          
          # 1.19.3+ execute conditions (pack_format 12+, mapping to 1)
          execute_subcommands["if dimension "]=1
          execute_subcommands["unless dimension "]=1
          execute_subcommands["if function "]=1
          execute_subcommands["unless function "]=1
          
          # 1.20.2+ execute conditions (pack_format 18+, mapping to 81)
          execute_subcommands["if biome "]=81
          execute_subcommands["unless biome "]=81
          execute_subcommands["if loaded "]=81
          execute_subcommands["unless loaded "]=81
          execute_subcommands["if items "]=81
          execute_subcommands["unless items "]=81
          
          # 1.21+ execute features (pack_format 48+)
          execute_subcommands["on "]=48
          execute_subcommands["summon "]=48
          
          # 1.21+ execute on relations (pack_format 48+)
          execute_subcommands["on attacker"]=48
          execute_subcommands["on controller"]=48
          execute_subcommands["on leasher"]=48
          execute_subcommands["on origin"]=48
          execute_subcommands["on owner"]=48
          execute_subcommands["on passengers"]=48
          execute_subcommands["on target"]=48
          execute_subcommands["on vehicle"]=48
          
          # Execute store variants
          execute_subcommands["store result "]=1
          execute_subcommands["store success "]=1
          
          while IFS= read -r -d $'\0' file; do
            total_funcs=$((total_funcs + 1))
            
            current_pack_format=0
            file_dir="$file"
            while [ "$file_dir" != "/" ] && [ "$file_dir" != "." ]; do
              if [ -f "$file_dir/pack.mcmeta" ]; then
                datapack_id=$(echo "$file_dir" | md5sum | cut -d' ' -f1)
                if [ -f "/tmp/pack_formats/${datapack_id}.txt" ]; then
                  current_pack_format=$(cut -d':' -f1 "/tmp/pack_formats/${datapack_id}.txt")
                fi
                break
              fi
              file_dir=$(dirname "$file_dir")
            done
            
            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            file_cmd_count=0
            line_num=0
            
            while IFS= read -r line; do
              line_num=$((line_num + 1))
              [[ "$line" =~ ^[[:space:]]*$ ]] && continue
              [[ "$line" =~ ^[[:space:]]*# ]] && continue
              
              file_cmd_count=$((file_cmd_count + 1))
              total_commands=$((total_commands + 1))
              
              clean_line=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              [[ "$clean_line" =~ ^/ ]] && clean_line="${clean_line:1}"
              cmd=$(echo "$clean_line" | awk '{print $1}')
              
              # Check deprecated commands
              if [ -n "${deprecated_commands[$cmd]}" ]; then
                echo "  âŒ $relative_path:$line_num - Deprecated: /$cmd"
                echo "     ğŸ’¡ ${deprecated_commands[$cmd]}"
                func_error=1
                continue
              fi
              
              # Check command compatibility
              if [ -n "${command_min_format[$cmd]}" ]; then
                required_format="${command_min_format[$cmd]}"
                if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt "$required_format" ]; then
                  echo "  âŒ $relative_path:$line_num - /$cmd requires pack_format $required_format+"
                  func_error=1
                fi
              elif [ "$STRICT_MODE" = "true" ]; then
                echo "  âš ï¸  $relative_path:$line_num - Unknown command: /$cmd"
                func_warnings=$((func_warnings + 1))
              fi
              
              # â˜… Check ALL execute subcommands
              if [[ "$clean_line" =~ ^execute ]]; then
                for sub in "${!execute_subcommands[@]}"; do
                  if [[ "$clean_line" =~ $sub ]]; then
                    required="${execute_subcommands[$sub]}"
                    if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt "$required" ]; then
                      echo "  âŒ $relative_path:$line_num - 'execute $sub' requires pack_format $required+"
                      func_error=1
                    fi
                  fi
                done
              fi
              
            done < "$file"
            
            [ $file_cmd_count -gt 0 ] && echo "  âœ“ $relative_path ($file_cmd_count commands)"
            
          done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
          
          echo "  ğŸ“Š Total: $total_funcs files, $total_commands commands"
          
          if [ $func_error -eq 0 ]; then
            echo "  âœ… Function validation passed"
            [ $func_warnings -gt 0 ] && echo "  âš ï¸  $func_warnings warning(s)"
          else
            echo "  âŒ Function validation failed"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          fi
          TOTAL_WARNINGS=$((TOTAL_WARNINGS + func_warnings))
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 5. MACRO VALIDATION
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”§ [5/8] Validating Macros..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          macro_error=0
          files_with_macros=0
          total_macro_vars=0
          
          while IFS= read -r -d $'\0' file; do
            current_pack_format=0
            file_dir="$file"
            while [ "$file_dir" != "/" ] && [ "$file_dir" != "." ]; do
              if [ -f "$file_dir/pack.mcmeta" ]; then
                datapack_id=$(echo "$file_dir" | md5sum | cut -d' ' -f1)
                if [ -f "/tmp/pack_formats/${datapack_id}.txt" ]; then
                  current_pack_format=$(cut -d':' -f1 "/tmp/pack_formats/${datapack_id}.txt")
                fi
                break
              fi
              file_dir=$(dirname "$file_dir")
            done
            
            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            macro_vars=$(grep -oP '\$\(\K[a-zA-Z0-9_]+(?=\))' "$file" 2>/dev/null | sort -u)
            macro_count=$(echo "$macro_vars" | grep -c '.' 2>/dev/null || echo 0)
            
            if [ $macro_count -gt 0 ]; then
              files_with_macros=$((files_with_macros + 1))
              total_macro_vars=$((total_macro_vars + macro_count))
              
              echo "  ğŸ”§ $relative_path ($macro_count macro variable(s))"
              echo "$macro_vars" | while read -r var; do
                [ -n "$var" ] && echo "     â€¢ \$($var)"
              done
              
              if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                echo "     âŒ Macros require pack_format 81+ (current: $current_pack_format)"
                macro_error=1
              fi
            fi
          done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
          
          if [ $macro_error -eq 0 ]; then
            if [ $files_with_macros -eq 0 ]; then
              echo "  â„¹ï¸  No macros detected"
            else
              echo "  âœ… Macro validation passed ($files_with_macros files, $total_macro_vars variables)"
            fi
          else
            echo "  âŒ Macro validation failed"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          fi
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 6. DIALOG & CHAT TYPE VALIDATION
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ’¬ [6/8] Validating Dialogs & Chat Types..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          dialog_error=0
          dialog_warnings=0
          dialog_count=0
          chat_type_count=0
          
          while IFS= read -r -d $'\0' file; do
            chat_type_count=$((chat_type_count + 1))
            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            
            echo "  ğŸ’¬ $relative_path"
            
            if ! jq -e '.chat' "$file" > /dev/null 2>&1; then
              echo "     âŒ Missing 'chat' field"
              dialog_error=1
            fi
            
            if ! jq -e '.narration' "$file" > /dev/null 2>&1; then
              echo "     âš ï¸  Missing 'narration' field (optional but recommended)"
              dialog_warnings=$((dialog_warnings + 1))
            fi
            
            if jq -e '.chat.translation_key' "$file" > /dev/null 2>&1; then
              trans_key=$(jq -r '.chat.translation_key' "$file")
              echo "     âœ“ Translation key: $trans_key"
            fi
            
          done < <(find new_versions -path "*/datapack/data/*/chat_type/*.json" -type f -print0 2>/dev/null || true)
          
          while IFS= read -r -d $'\0' file; do
            if grep -q "^\s*dialog\s" "$file" 2>/dev/null; then
              dialog_count=$((dialog_count + 1))
              relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
              
              current_pack_format=0
              file_dir="$file"
              while [ "$file_dir" != "/" ] && [ "$file_dir" != "." ]; do
                if [ -f "$file_dir/pack.mcmeta" ]; then
                  datapack_id=$(echo "$file_dir" | md5sum | cut -d' ' -f1)
                  if [ -f "/tmp/pack_formats/${datapack_id}.txt" ]; then
                    current_pack_format=$(cut -d':' -f1 "/tmp/pack_formats/${datapack_id}.txt")
                  fi
                  break
                fi
                file_dir=$(dirname "$file_dir")
              done
              
              echo "  ğŸ—¨ï¸  $relative_path uses /dialog command"
              
              if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 48 ]; then
                echo "     âŒ /dialog requires pack_format 48+ (Minecraft 1.21)"
                dialog_error=1
              fi
            fi
          done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
          
          if [ $dialog_error -eq 0 ]; then
            if [ $chat_type_count -eq 0 ] && [ $dialog_count -eq 0 ]; then
              echo "  â„¹ï¸  No dialogs or custom chat types detected"
            else
              echo "  âœ… Dialog validation passed"
              [ $chat_type_count -gt 0 ] && echo "     ğŸ“ Chat types: $chat_type_count"
              [ $dialog_count -gt 0 ] && echo "     ğŸ—¨ï¸  Dialog commands: $dialog_count"
              [ $dialog_warnings -gt 0 ] && echo "  âš ï¸  $dialog_warnings warning(s)"
            fi
          else
            echo "  âŒ Dialog validation failed"
            TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
          fi
          TOTAL_WARNINGS=$((TOTAL_WARNINGS + dialog_warnings))
          echo ""
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 7. SECURITY ANALYSIS
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if [ "$SECURITY_CHECK" = "true" ]; then
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ”’ [7/8] Security Analysis..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            sec_error=0
            sec_warnings=0
            
            # BACKDOOR & PRIVILEGE ESCALATION PATTERNS
            declare -A suspicious_patterns
            
            # Admin privilege abuse (OP without selectors = backdoor)
            suspicious_patterns["^[^#]*\sop\s@[ape]\s*$"]="CRITICAL: Blanket OP grant - potential backdoor"
            suspicious_patterns["^[^#]*\sop\s@[ape]\["]="WARNING: OP grant with selector - verify legitimacy"
            
            # Server control abuse (exclude function calls like namespace:stop)
            suspicious_patterns["^[^#:]*\sstop\s*$"]="CRITICAL: Server shutdown command detected"
            suspicious_patterns["^[^#:]*\srestart\s*$"]="WARNING: Server restart command detected"
            
            # External code execution attempts
            suspicious_patterns["<script"]="CRITICAL: JavaScript injection attempt in NBT/JSON"
            suspicious_patterns["javascript:"]="CRITICAL: JavaScript protocol in clickEvent"
            suspicious_patterns["eval\("]="CRITICAL: JavaScript eval() detected"
            suspicious_patterns["Function\("]="CRITICAL: JavaScript Function() constructor detected"
            suspicious_patterns["\.js[\"']"]="WARNING: JavaScript file reference detected"
            
            # Command injection patterns (excluding Minecraft macros)
            suspicious_patterns["&&"]="WARNING: Command chaining operator detected"
            suspicious_patterns[";\s*op\s"]="CRITICAL: Command injection attempt - OP after semicolon"
            suspicious_patterns["\|\s*op\s"]="CRITICAL: Pipe to OP command - potential exploit"
            
            # Unauthorized system access
            suspicious_patterns["file://"]="CRITICAL: File protocol - potential file system access"
            suspicious_patterns["\.\.\/"]="WARNING: Directory traversal pattern detected"
            
            # Phishing & malicious URLs
            suspicious_patterns["clickEvent.*run_command.*op"]="CRITICAL: ClickEvent grants OP - backdoor"
            suspicious_patterns["clickEvent.*run_command.*sudo"]="CRITICAL: Sudo-like pattern in clickEvent"
            suspicious_patterns["hoverEvent.*run_command.*op"]="CRITICAL: HoverEvent grants OP - backdoor"
            
            echo "  ğŸ” Scanning for backdoors & code injection..."
            echo "     â€¢ OP privilege escalation"
            echo "     â€¢ JavaScript/external code execution"
            echo "     â€¢ Command injection patterns"
            echo "     â€¢ Unauthorized system access"
            echo "     â€¢ Book-based phishing"
            echo ""
            
            # First: Scan mcfunction files for book menus
            echo "  ğŸ“š Scanning for book menu systems..."
            book_menu_count=0
            
            while IFS= read -r -d $'\0' file; do
              relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
              line_num=0
              file_has_books=0
              
              while IFS= read -r line; do
                line_num=$((line_num + 1))
                [[ "$line" =~ ^[[:space:]]*$ ]] && continue
                [[ "$line" =~ ^[[:space:]]*# ]] && continue
                
                # Detect written_book with pages in give/item/data commands
                if [[ "$line" =~ (give|item|data).*written_book.*pages ]]; then
                  if [ $file_has_books -eq 0 ]; then
                    echo "  ğŸ“– $relative_path - Contains book menu system:"
                    file_has_books=1
                    book_menu_count=$((book_menu_count + 1))
                  fi
                  
                  # Check for phishing indicators
                  if [[ "$line" =~ clickEvent ]]; then
                    if [[ "$line" =~ open_url ]]; then
                      echo "     ğŸš¨ Line $line_num: CRITICAL - Book with URL clickEvent (phishing)"
                      sec_warnings=$((sec_warnings + 1))
                      SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
                    elif [[ "$line" =~ run_command.*op ]]; then
                      echo "     ğŸš¨ Line $line_num: CRITICAL - Book grants OP via clickEvent"
                      sec_warnings=$((sec_warnings + 1))
                      SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
                    else
                      echo "     âš ï¸  Line $line_num: Book with clickEvent - verify legitimacy"
                      echo "        Preview: ${line:0:100}..."
                    fi
                  else
                    echo "     â„¹ï¸  Line $line_num: Book menu (no clickEvents)"
                  fi
                fi
              done < "$file"
              
            done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
            
            if [ $book_menu_count -gt 0 ]; then
              echo "  ğŸ“Š Found $book_menu_count function(s) with book menu systems"
            else
              echo "  âœ… No book menu systems detected in functions"
            fi
            echo ""
            
            # Then: Scan for other security patterns
            echo "  ğŸ” Scanning for other security threats..."
            
            while IFS= read -r -d $'\0' file; do
              relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
              line_num=0
              
              while IFS= read -r line; do
                line_num=$((line_num + 1))
                [[ "$line" =~ ^[[:space:]]*$ ]] && continue
                [[ "$line" =~ ^[[:space:]]*# ]] && continue
                
                for pattern in "${!suspicious_patterns[@]}"; do
                  if [[ "$line" =~ $pattern ]]; then
                    echo "  âš ï¸  $relative_path:$line_num"
                    echo "     Pattern: '$pattern'"
                    echo "     Reason: ${suspicious_patterns[$pattern]}"
                    echo "     Line: ${line:0:80}..."
                    sec_warnings=$((sec_warnings + 1))
                    SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
                  fi
                done
              done < "$file"
            done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
            
            # Check JSON files for book/phishing patterns
            while IFS= read -r -d $'\0' file; do
              relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
              
              # Skip legitimate locations
              if [[ "$relative_path" =~ loot_table ]] || [[ "$relative_path" =~ loot_tables ]]; then
                continue  # Loot tables are legitimate
              fi
              
              # Check for phishing patterns
              if grep -qE "pages.*clickEvent.*open_url" "$file" 2>/dev/null; then
                echo "  ğŸš¨ $relative_path"
                echo "     Reason: CRITICAL - Book with URL clickEvents (phishing risk)"
                sec_warnings=$((sec_warnings + 1))
                SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
              elif grep -qE "written_book.*pages.*clickEvent" "$file" 2>/dev/null; then
                echo "  âš ï¸  $relative_path"
                echo "     Reason: WARNING - Book with clickable pages (verify legitimacy)"
                sec_warnings=$((sec_warnings + 1))
                SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
              fi
            done < <(find new_versions -name "*.json" -type f -print0 2>/dev/null || true)
            
            # Check for obfuscated code
            echo ""
            echo "  ğŸ” Checking for obfuscated code..."
            obfuscated_count=0
            
            while IFS= read -r -d $'\0' file; do
              relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
              
              # Check for suspicious namespace names
              if [[ "$file" =~ /data/([^/]+)/ ]]; then
                namespace="${BASH_REMATCH[1]}"
                # Single char namespaces or very long random strings
                if [[ ${#namespace} -eq 1 ]] || [[ "$namespace" =~ ^[a-z0-9]{32,}$ ]]; then
                  echo "  âš ï¸  Suspicious namespace: $namespace in $relative_path"
                  obfuscated_count=$((obfuscated_count + 1))
                  sec_warnings=$((sec_warnings + 1))
                  SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
                fi
              fi
              
              # Check for overly long function names (possible obfuscation)
              func_name=$(basename "$file" .mcfunction)
              if [ ${#func_name} -gt 64 ]; then
                echo "  âš ï¸  Suspiciously long function name (${#func_name} chars): ${func_name:0:40}..."
                sec_warnings=$((sec_warnings + 1))
                SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
              fi
            done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
            
            # Summary
            if [ $SECURITY_ISSUES -eq 0 ]; then
              echo ""
              echo "  âœ… No backdoors or code injection detected"
              echo "  ğŸ”’ Datapack appears safe for production use"
            else
              echo ""
              echo "  âš ï¸  Security scan complete: $SECURITY_ISSUES potential threat(s) found"
              echo "  ğŸš¨ CRITICAL issues require immediate review"
              echo "  ğŸ’¡ WARNING issues should be verified for legitimacy"
            fi
            
            TOTAL_WARNINGS=$((TOTAL_WARNINGS + sec_warnings))
            echo ""
          fi
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # 8. PERFORMANCE ANALYSIS
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if [ "$PERFORMANCE_CHECK" = "true" ]; then
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âš¡ [8/8] Performance Analysis..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            perf_warnings=0
            
            echo "  ğŸ” Checking for performance issues..."
            
            # Performance patterns - only flag inefficient usage
            declare -A perf_patterns
            
            # Entity selectors WITHOUT filtering = performance issue
            perf_patterns["execute as @e[^[]"]="@e without selector - performance impact, add [type=] filter"
            perf_patterns["execute at @e[^[]"]="@e without selector - expensive position check"
            perf_patterns["@e[^[]*run"]="@e iteration without filters - add type/tag/distance"
            
            # Large world modifications
            perf_patterns["fill.*~[0-9]{3,}"]="Large fill operation (100+ blocks) - performance impact"
            perf_patterns["clone.*~[0-9]{3,}"]="Large clone operation (100+ blocks) - performance impact"
            
            # Complex NBT operations
            perf_patterns["summon.*Passengers.*Passengers"]="Deeply nested entity structure - lag risk"
            
            while IFS= read -r -d $'\0' file; do
              relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
              line_num=0
              file_perf_issues=0
              
              while IFS= read -r line; do
                line_num=$((line_num + 1))
                [[ "$line" =~ ^[[:space:]]*$ ]] && continue
                [[ "$line" =~ ^[[:space:]]*# ]] && continue
                
                for pattern in "${!perf_patterns[@]}"; do
                  if [[ "$line" =~ $pattern ]]; then
                    if [ $file_perf_issues -eq 0 ]; then
                      echo "  âš ï¸  $relative_path"
                    fi
                    echo "     Line $line_num: ${perf_patterns[$pattern]}"
                    file_perf_issues=$((file_perf_issues + 1))
                    perf_warnings=$((perf_warnings + 1))
                    PERFORMANCE_ISSUES=$((PERFORMANCE_ISSUES + 1))
                  fi
                done
              done < "$file"
            done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0 2>/dev/null || true)
            
            # Check for tick functions
            echo ""
            echo "  ğŸ” Analyzing tick functions..."
            tick_count=0
            
            while IFS= read -r -d $'\0' file; do
              if jq -e '.values[]' "$file" 2>/dev/null | grep -q "tick"; then
                tick_count=$((tick_count + 1))
                relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
                echo "  ğŸ“Œ Tick function tag: $relative_path"
                
                # Count commands in tick functions
                tick_funcs=$(jq -r '.values[]' "$file" 2>/dev/null)
                while IFS= read -r func_path; do
                  func_file=$(find new_versions -path "*/function/${func_path#*:}.mcfunction" -type f 2>/dev/null | head -1)
                  if [ -n "$func_file" ]; then
                    cmd_count=$(grep -cEv '^[[:space:]]*$|^[[:space:]]*#' "$func_file" 2>/dev/null || echo 0)
                    
                    # CRITICAL: Check for problematic commands in tick
                    critical_cmds=$(grep -E '^\s*(deop|say|tell|msg|w|me)\s' "$func_file" 2>/dev/null)
                    if [ -n "$critical_cmds" ]; then
                      echo "     âŒ CRITICAL: Tick function contains prohibited commands: $func_path"
                      echo "        Commands in tick run 20 times/second:"
                      echo "        â€¢ /deop = instant admin removal loop"
                      echo "        â€¢ /say,/tell,/msg = chat spam (400 msgs in 20s)"
                      echo "$critical_cmds" | while IFS= read -r cmd_line; do
                        echo "        Line: ${cmd_line:0:60}..."
                      done
                      perf_warnings=$((perf_warnings + 1))
                      PERFORMANCE_ISSUES=$((PERFORMANCE_ISSUES + 1))
                    fi
                    
                    if [ "$cmd_count" -gt 50 ]; then
                      echo "     âš ï¸  Large tick function: $func_path ($cmd_count commands)"
                      perf_warnings=$((perf_warnings + 1))
                      PERFORMANCE_ISSUES=$((PERFORMANCE_ISSUES + 1))
                    else
                      echo "     âœ“ $func_path ($cmd_count commands)"
                    fi
                  fi
                done <<< "$tick_funcs"
              fi
            done < <(find new_versions -path "*/datapack/data/*/tags/function/tick.json" -type f -print0 2>/dev/null || true)
            
            if [ $PERFORMANCE_ISSUES -eq 0 ]; then
              echo ""
              echo "  âœ… No performance issues detected"
            else
              echo ""
              echo "  âš ï¸  Performance analysis: $PERFORMANCE_ISSUES potential issue(s)"
              echo "  ğŸ’¡ Consider optimizing flagged operations"
            fi
            
            TOTAL_WARNINGS=$((TOTAL_WARNINGS + perf_warnings))
            echo ""
          fi
          
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # FINAL SUMMARY
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ VALIDATION SUMMARY"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  ğŸ“¦ Datapacks:           $datapack_count"
          echo "  ğŸ“„ JSON files:          $json_count"
          echo "  âš™ï¸  Functions:           $total_funcs"
          echo "  ğŸ’¬ Commands:            $total_commands"
          echo "  ğŸ”§ With macros:         $files_with_macros"
          echo "  ğŸ’¬ Chat types:          $chat_type_count"
          echo "  ğŸ—¨ï¸  Dialog usage:        $dialog_count"
          echo ""
          
          if [ "$SECURITY_CHECK" = "true" ]; then
            echo "  ğŸ”’ Security issues:     $SECURITY_ISSUES"
          fi
          
          if [ "$PERFORMANCE_CHECK" = "true" ]; then
            echo "  âš¡ Performance issues:  $PERFORMANCE_ISSUES"
          fi
          echo ""
          
          if [ $TOTAL_ERRORS -eq 0 ]; then
            echo "  âœ… ALL VALIDATIONS PASSED"
            [ $TOTAL_WARNINGS -gt 0 ] && echo "  âš ï¸  $TOTAL_WARNINGS warning(s) detected"
            [ $SECURITY_ISSUES -gt 0 ] && echo "  ğŸ”’ $SECURITY_ISSUES security notice(s) - review recommended"
            [ $PERFORMANCE_ISSUES -gt 0 ] && echo "  âš¡ $PERFORMANCE_ISSUES performance notice(s) - optimization recommended"
            echo ""
            echo "  ğŸš€ Datapack is production-ready for Minecraft 1.21+"
          else
            echo "  âŒ VALIDATION FAILED"
            echo "  âŒ Errors: $TOTAL_ERRORS"
            echo "  âš ï¸  Warnings: $TOTAL_WARNINGS"
            [ $SECURITY_ISSUES -gt 0 ] && echo "  ğŸ”’ Security issues: $SECURITY_ISSUES"
            [ $PERFORMANCE_ISSUES -gt 0 ] && echo "  âš¡ Performance issues: $PERFORMANCE_ISSUES"
            echo ""
            echo "  Common issues:"
            echo "    â€¢ pack_format must be 48, 81, 88, or 94"
            echo "    â€¢ Commands must match pack_format requirements"
            echo "    â€¢ Macros require pack_format 81+"
            echo "    â€¢ /dialog and /transfer require pack_format 48+ (1.21)"
            echo "    â€¢ /deop,/say,/tell in tick functions = BANNED"
            echo "    â€¢ Book menus flagged if not in loot_tables"
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Export metrics
          echo "total_errors=$TOTAL_ERRORS" >> $GITHUB_OUTPUT
          echo "total_warnings=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT
          echo "security_issues=$SECURITY_ISSUES" >> $GITHUB_OUTPUT
          echo "performance_issues=$PERFORMANCE_ISSUES" >> $GITHUB_OUTPUT
          echo "total_commands=$total_commands" >> $GITHUB_OUTPUT
          echo "total_functions=$total_funcs" >> $GITHUB_OUTPUT
          echo "files_with_macros=$files_with_macros" >> $GITHUB_OUTPUT
          
          [ $TOTAL_ERRORS -gt 0 ] && exit 1
          exit 0

      - name: Comment PR with Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const errors = ${{ steps.validation.outputs.total_errors }};
            const warnings = ${{ steps.validation.outputs.total_warnings }};
            const security = ${{ steps.validation.outputs.security_issues }};
            const performance = ${{ steps.validation.outputs.performance_issues }};
            const macros = ${{ steps.validation.outputs.files_with_macros }};
            
            let status = errors === 0 ? 'âœ… **PASSED**' : 'âŒ **FAILED**';
            let color = errors === 0 ? 'ğŸŸ¢' : 'ğŸ”´';
            
            const body = `
            ## ${color} Datapack Validation Results
            
            **Status:** ${status}
            
            ### ğŸ“Š Metrics
            - **Functions:** ${{ steps.validation.outputs.total_functions }}
            - **Commands:** ${{ steps.validation.outputs.total_commands }}
            - **Files with Macros:** ${macros}
            - **Errors:** ${errors}
            - **Warnings:** ${warnings}
            - **Security Issues:** ${security}
            - **Performance Issues:** ${performance}
            
            ${errors > 0 ? '### âŒ Action Required\nPlease fix the errors listed in the workflow logs.' : ''}
            ${security > 0 ? '### ğŸ”’ Security Notice\nSome patterns were flagged for review. Please verify they are intentional.' : ''}
            ${performance > 0 ? '### âš¡ Performance Notice\nConsider optimizing flagged operations for better performance.' : ''}
            ${macros > 0 ? '### ğŸ”§ Macro Usage\nThis datapack uses macros. Ensure pack_format is 81+.' : ''}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
