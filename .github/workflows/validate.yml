name: Validate Datapack (MC 1.21)

on:
  pull_request:
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  push:
    branches:
      - main
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  workflow_dispatch:

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq tree
          echo "âœ… Dependencies installed"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # JSON SYNTAX VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate JSON Syntax
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Validating JSON Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          count=0
          failed_files=()

          while IFS= read -r -d $'\0' file; do
            count=$((count + 1))
            echo "  Checking: $file"
            
            if ! jq empty "$file" 2>/dev/null; then
              echo "  âŒ Invalid JSON syntax: $file"
              failed_files+=("$file")
              error=1
            fi
          done < <(find new_versions -name "*.json" -type f -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… All $count JSON files are valid"
          else
            echo "âŒ Failed validation for ${#failed_files[@]} file(s):"
            printf '   - %s\n' "${failed_files[@]}"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FORBIDDEN METADATA CHECK
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Check Forbidden Auth Metadata
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”’ Checking Forbidden Metadata..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          violations=()

          # Check for ely.by metadata
          while IFS= read -r -d $'\0' file; do
            if jq -e '
              .. | objects |
              select(
                (.name? == "ely") and
                (.value? == "but why are you asking?")
              )
            ' "$file" > /dev/null 2>&1; then
              echo "  âŒ Forbidden ely.by metadata in: $file"
              violations+=("$file (ely.by)")
              error=1
            fi

            # Check for other suspicious auth patterns
            if jq -e '
              .. | objects |
              select(
                .authlib? or
                .authentication? or
                (.name? | test("auth|login|credential"; "i"))
              )
            ' "$file" > /dev/null 2>&1; then
              echo "  âš ï¸  Suspicious auth pattern in: $file"
            fi
          done < <(find new_versions -name "*.json" -type f -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… No forbidden metadata found"
          else
            echo "âŒ Found ${#violations[@]} violation(s)"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PACK.MCMETA VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate pack.mcmeta Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ Validating pack.mcmeta Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          found=0
          error=0
          warnings=0

          # GeÃ§erli pack format deÄŸerleri
          VALID_FORMATS=(81 88 94)
          INVALID_THRESHOLD=80

          while IFS= read -r -d $'\0' file; do
            found=1
            echo "  Checking: $file"

            # Required: pack.pack_format
            if ! jq -e '.pack.pack_format' "$file" > /dev/null 2>&1; then
              echo "    âŒ Missing pack.pack_format"
              error=1
            else
              pack_format=$(jq -r '.pack.pack_format' "$file")
              echo "    â„¹ï¸  Pack format: $pack_format"
              
              # Pack format kontrolÃ¼
              is_valid=0
              for valid_format in "${VALID_FORMATS[@]}"; do
                if [ "$pack_format" -eq "$valid_format" ]; then
                  is_valid=1
                  break
                fi
              done

              if [ $is_valid -eq 1 ]; then
                case $pack_format in
                  81)
                    echo "    âœ… Valid pack format: 81"
                    ;;
                  88)
                    echo "    âœ… Valid pack format: 88"
                    ;;
                  94)
                    echo "    âœ… Valid pack format: 94"
                    ;;
                esac
              elif [ "$pack_format" -le "$INVALID_THRESHOLD" ]; then
                echo "    âŒ Invalid/Incompatible pack format: $pack_format (must be 81, 88, or 94)"
                error=1
              else
                echo "    âš ï¸  Unknown pack format: $pack_format (expected: 81, 88, or 94)"
                warnings=$((warnings + 1))
              fi

              # Pack format bilgilerini kaydet (mcfunction kontrolÃ¼ iÃ§in)
              echo "$pack_format" > "/tmp/pack_format_$(basename $(dirname $file)).txt"
            fi

            # Required: pack.description
            if ! jq -e '.pack.description' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  Missing pack.description"
              warnings=$((warnings + 1))
            else
              description=$(jq -r '.pack.description' "$file")
              echo "    â„¹ï¸  Description: $description"
            fi

            # Check for supported_formats
            if jq -e '.pack.supported_formats' "$file" > /dev/null 2>&1; then
              supported=$(jq -r '.pack.supported_formats' "$file")
              echo "    â„¹ï¸  Supported formats: $supported"
              
              # Validate supported_formats
              for valid_format in "${VALID_FORMATS[@]}"; do
                if jq -e ".pack.supported_formats | if type == \"array\" then (. | index($valid_format)) elif type == \"object\" then (.min_inclusive <= $valid_format and .max_inclusive >= $valid_format) else false end" "$file" > /dev/null 2>&1; then
                  echo "    âœ… Supports pack format $valid_format"
                fi
              done
            fi

            # Check for filter
            if jq -e '.filter' "$file" > /dev/null 2>&1; then
              block_count=$(jq '.filter.block | length' "$file" 2>/dev/null || echo 0)
              echo "    â„¹ï¸  Filter with $block_count block pattern(s)"
            fi

            # Check for overlays
            if jq -e '.overlays' "$file" > /dev/null 2>&1; then
              overlay_count=$(jq '.overlays.entries | length' "$file")
              echo "    â„¹ï¸  Has $overlay_count overlay(s)"
            fi

            # Check for features
            if jq -e '.features' "$file" > /dev/null 2>&1; then
              echo "    â„¹ï¸  Has feature flags defined"
            fi

            echo ""
          done < <(find new_versions -name "pack.mcmeta" -type f -print0)

          if [ $found -eq 0 ]; then
            echo "âŒ No pack.mcmeta files found"
            exit 1
          fi

          if [ $error -eq 0 ]; then
            echo "âœ… All pack.mcmeta files are valid"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo "âŒ pack.mcmeta validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # DATAPACK STRUCTURE VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Datapack Structure
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Validating Datapack Structure..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          datapack_count=0

          while IFS= read -r -d $'\0' file; do
            dir=$(dirname "$file")
            datapack_count=$((datapack_count + 1))
            echo "  Datapack #$datapack_count: $dir"

            # Check for data/ directory
            if [ ! -d "$dir/data" ]; then
              echo "    âŒ Missing data/ directory"
              error=1
            else
              echo "    âœ… data/ directory exists"
              
              # Count namespaces
              namespace_count=$(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
              echo "    â„¹ï¸  Found $namespace_count namespace(s)"

              # List namespaces
              if [ $namespace_count -gt 0 ]; then
                while IFS= read -r namespace; do
                  ns_name=$(basename "$namespace")
                  echo "      â†’ $ns_name"
                  
                  # Standard directories
                  [ -d "$namespace/advancement" ] && echo "        âœ“ advancement/"
                  [ -d "$namespace/function" ] && echo "        âœ“ function/"
                  [ -d "$namespace/item_modifier" ] && echo "        âœ“ item_modifier/"
                  [ -d "$namespace/loot_table" ] && echo "        âœ“ loot_table/"
                  [ -d "$namespace/predicate" ] && echo "        âœ“ predicate/"
                  [ -d "$namespace/recipe" ] && echo "        âœ“ recipe/"
                  [ -d "$namespace/structure" ] && echo "        âœ“ structure/"
                  [ -d "$namespace/tags" ] && echo "        âœ“ tags/"
                  
                  # Worldgen directories
                  [ -d "$namespace/worldgen" ] && echo "        âœ“ worldgen/"
                  [ -d "$namespace/dimension" ] && echo "        âœ“ dimension/"
                  [ -d "$namespace/dimension_type" ] && echo "        âœ“ dimension_type/"
                  
                  # New directories
                  [ -d "$namespace/damage_type" ] && echo "        âœ“ damage_type/"
                  [ -d "$namespace/trim_material" ] && echo "        âœ“ trim_material/"
                  [ -d "$namespace/trim_pattern" ] && echo "        âœ“ trim_pattern/"
                  [ -d "$namespace/chat_type" ] && echo "        âœ“ chat_type/"
                  [ -d "$namespace/banner_pattern" ] && echo "        âœ“ banner_pattern/"
                  [ -d "$namespace/enchantment" ] && echo "        âœ“ enchantment/"
                  [ -d "$namespace/jukebox_song" ] && echo "        âœ“ jukebox_song/"
                  [ -d "$namespace/painting_variant" ] && echo "        âœ“ painting_variant/"
                  [ -d "$namespace/wolf_variant" ] && echo "        âœ“ wolf_variant/"
                  
                done < <(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)
              fi
            fi

            echo ""
          done < <(find new_versions -name "pack.mcmeta" -type f -print0)

          if [ $error -eq 0 ]; then
            echo "âœ… Datapack structure validation passed"
          else
            echo "âŒ Datapack structure validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MCFUNCTION CONTENT VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Function Files Content
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âš™ï¸  Validating Function Files Content..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          warnings=0
          total_count=0
          total_lines=0

          # Komut kategorileri ve uyumluluk bilgileri
          declare -A command_compatibility
          
          # Temel komutlar (tÃ¼m versiyonlarda geÃ§erli)
          command_compatibility["execute"]="all"
          command_compatibility["function"]="all"
          command_compatibility["say"]="all"
          command_compatibility["tellraw"]="all"
          command_compatibility["give"]="all"
          command_compatibility["summon"]="all"
          command_compatibility["kill"]="all"
          command_compatibility["tp"]="all"
          command_compatibility["teleport"]="all"
          command_compatibility["fill"]="all"
          command_compatibility["setblock"]="all"
          command_compatibility["particle"]="all"
          command_compatibility["playsound"]="all"
          command_compatibility["effect"]="all"
          command_compatibility["enchant"]="all"
          command_compatibility["scoreboard"]="all"
          command_compatibility["team"]="all"
          command_compatibility["tag"]="all"
          command_compatibility["data"]="all"
          command_compatibility["gamemode"]="all"
          command_compatibility["difficulty"]="all"
          command_compatibility["weather"]="all"
          command_compatibility["time"]="all"
          command_compatibility["gamerule"]="all"
          command_compatibility["setworldspawn"]="all"
          command_compatibility["spawnpoint"]="all"
          command_compatibility["worldborder"]="all"
          command_compatibility["schedule"]="all"
          command_compatibility["forceload"]="all"
          command_compatibility["clone"]="all"
          command_compatibility["clear"]="all"
          command_compatibility["item"]="81"
          
          # Yeni komutlar
          command_compatibility["damage"]="81"  # 1.19.4+
          command_compatibility["ride"]="81"    # 1.19.4+
          command_compatibility["return"]="81"  # 1.20+
          command_compatibility["tick"]="81"    # 1.20+
          command_compatibility["random"]="81"  # 1.20.2+
          
          # KaldÄ±rÄ±lan/deÄŸiÅŸtirilen komutlar
          command_compatibility["replaceitem"]="deprecated"  # 1.17'de kaldÄ±rÄ±ldÄ±, /item kullan

          while IFS= read -r -d $'\0' file; do
            total_count=$((total_count + 1))
            line_count=$(wc -l < "$file")
            total_lines=$((total_lines + line_count))

            # Datapack'in pack.mcmeta dosyasÄ±nÄ± bul
            datapack_root=$(echo "$file" | grep -o '.*/datapack' | head -1)
            pack_mcmeta="$datapack_root/pack.mcmeta"
            
            current_pack_format=0
            if [ -f "$pack_mcmeta" ]; then
              current_pack_format=$(jq -r '.pack.pack_format' "$pack_mcmeta" 2>/dev/null || echo 0)
            fi

            echo "  Checking: $file (pack_format: $current_pack_format)"

            # BoÅŸ dosya kontrolÃ¼
            if [ $line_count -eq 0 ]; then
              echo "    âš ï¸  Empty function file"
              warnings=$((warnings + 1))
            fi

            # Windows satÄ±r sonu kontrolÃ¼
            if grep -q $'\r' "$file"; then
              echo "    âŒ Windows line endings (CRLF) detected - use LF only"
              error=1
            fi

            # Tab karakteri kontrolÃ¼
            if grep -q $'\t' "$file"; then
              echo "    âš ï¸  Contains tab characters - use spaces instead"
              warnings=$((warnings + 1))
            fi

            # Komut iÃ§eriÄŸi analizi
            line_num=0
            while IFS= read -r line; do
              line_num=$((line_num + 1))
              
              # BoÅŸ satÄ±r ve yorum kontrolÃ¼
              [[ "$line" =~ ^[[:space:]]*$ ]] && continue
              [[ "$line" =~ ^[[:space:]]*# ]] && continue

              # Komut baÅŸlangÄ±cÄ±nÄ± al
              cmd=$(echo "$line" | sed 's/^[[:space:]]*//' | cut -d' ' -f1 | sed 's|^/||')

              # Komut uyumluluk kontrolÃ¼
              if [ -n "${command_compatibility[$cmd]}" ]; then
                required_format="${command_compatibility[$cmd]}"
                
                if [ "$required_format" = "deprecated" ]; then
                  echo "    âŒ Line $line_num: Deprecated command '/$cmd' - this command is no longer available"
                  error=1
                elif [ "$required_format" != "all" ] && [ "$current_pack_format" -lt "$required_format" ]; then
                  echo "    âŒ Line $line_num: Command '/$cmd' requires pack_format $required_format or higher (current: $current_pack_format)"
                  error=1
                fi
              fi

              # Execute subcommand kontrolÃ¼ (pack_format 81+)
              if [[ "$line" =~ execute ]]; then
                # if/unless biome (1.20+)
                if [[ "$line" =~ execute.*(if|unless).*biome ]] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: 'execute if/unless biome' requires pack_format 81+ (current: $current_pack_format)"
                  error=1
                fi
                
                # if/unless dimension (1.20+)
                if [[ "$line" =~ execute.*(if|unless).*dimension ]] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: 'execute if/unless dimension' requires pack_format 81+ (current: $current_pack_format)"
                  error=1
                fi
                
                # on relation (1.20+)
                if [[ "$line" =~ execute.*on ]] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: 'execute on' requires pack_format 81+ (current: $current_pack_format)"
                  error=1
                fi

                # summon (1.20+)
                if [[ "$line" =~ execute.*summon ]] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    â„¹ï¸  Line $line_num: 'execute summon' available in pack_format 81+"
                fi
              fi

              # Macro kontrolÃ¼ $(variable) (1.20.2+, pack_format 81+)
              if [[ "$line" =~ \$\( ]]; then
                if [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: Macros \$(variable) require pack_format 81+ (current: $current_pack_format)"
                  error=1
                else
                  echo "    â„¹ï¸  Line $line_num: Uses macro syntax"
                fi
              fi

              # ÅÃ¼pheli pattern kontrolÃ¼
              if [[ "$line" =~ execute.*run.*execute.*run.*execute ]]; then
                echo "    âš ï¸  Line $line_num: Very complex execute chain detected"
                warnings=$((warnings + 1))
              fi

              # .. path traversal kontrolÃ¼
              if [[ "$line" =~ /function.*\.\. ]]; then
                echo "    âŒ Line $line_num: Path traversal (..) is not allowed in function paths"
                error=1
              fi

              # Selector kontrolÃ¼
              if [[ "$line" =~ @[parse] ]]; then
                # type selector kontrolÃ¼
                if [[ "$line" =~ type= ]]; then
                  echo "    â„¹ï¸  Line $line_num: Uses entity type selector"
                fi
                
                # limit kontrolÃ¼
                if [[ "$line" =~ limit= ]]; then
                  echo "    â„¹ï¸  Line $line_num: Uses limit selector"
                fi
              fi

            done < "$file"

            echo ""

          done < <(find new_versions -name "*.mcfunction" -type f -print0)

          echo ""
          echo "ğŸ“Š Function Statistics:"
          echo "   Total files: $total_count"
          echo "   Total lines: $total_lines"
          [ $total_count -gt 0 ] && echo "   Average lines per file: $((total_lines / total_count))"

          if [ $error -eq 0 ]; then
            echo ""
            echo "âœ… Function content validation passed"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo ""
            echo "âŒ Function content validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # NAMESPACE VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Namespaces
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ·ï¸  Validating Namespaces..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          
          while IFS= read -r -d $'\0' namespace; do
            ns_name=$(basename "$namespace")
            echo "  Checking namespace: $ns_name"

            # Namespace isimlendirme kuralÄ±
            if ! [[ "$ns_name" =~ ^[a-z0-9_.-]+$ ]]; then
              echo "    âŒ Invalid namespace name (use lowercase, numbers, _, ., - only)"
              error=1
            fi

            # minecraft namespace kontrolÃ¼
            if [ "$ns_name" = "minecraft" ]; then
              echo "    âš ï¸  Using reserved 'minecraft' namespace (not recommended)"
            fi

            # Uzunluk kontrolÃ¼
            if [ ${#ns_name} -gt 255 ]; then
              echo "    âŒ Namespace name too long (max 255 characters)"
              error=1
            fi

          done < <(find new_versions -path "*/data/*" -mindepth 1 -maxdepth 1 -type d -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… Namespace validation passed"
          else
            echo "âŒ Namespace validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # TAG FILES VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Tag Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ·ï¸  Validating Tag Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          tag_count=0
          error=0
          warnings=0

          # Tag kategorileri
          declare -A tag_categories=(
            ["blocks"]="Block tags"
            ["items"]="Item tags"
            ["entity_types"]="Entity type tags"
            ["fluids"]="Fluid tags"
            ["game_events"]="Game event tags"
            ["functions"]="Function tags"
            ["damage_type"]="Damage type tags"
            ["enchantment"]="Enchantment tags"
            ["instrument"]="Instrument tags"
            ["cat_variant"]="Cat variant tags"
            ["painting_variant"]="Painting variant tags"
            ["point_of_interest_type"]="POI type tags"
            ["worldgen/biome"]="Biome tags"
            ["worldgen/structure"]="Structure tags"
            ["banner_pattern"]="Banner pattern tags"
            ["chat_type"]="Chat type tags"
          )

          while IFS= read -r -d $'\0' file; do
            tag_count=$((tag_count + 1))
            
            # Tag yapÄ±sÄ± kontrolÃ¼
            if ! jq -e '.values' "$file" > /dev/null 2>&1; then
              echo "  âŒ Missing 'values' array in: $file"
              error=1
              continue
            fi

            # replace field kontrolÃ¼
            if jq -e '.replace' "$file" > /dev/null 2>&1; then
              replace_val=$(jq -r '.replace' "$file")
              echo "  â„¹ï¸  Tag uses 'replace: $replace_val': $file"
            fi

            # values sayÄ±sÄ±
            values_count=$(jq '.values | length' "$file")
            if [ "$values_count" -eq 0 ]; then
              echo "  âš ï¸  Empty values array in: $file"
              warnings=$((warnings + 1))
            fi

            # required/optional fields
            if jq -e '.values[] | select(type == "object") | .required' "$file" > /dev/null 2>&1; then
              echo "  â„¹ï¸  Uses required/optional fields: $file"
            fi

            # Tag kategorisi tespiti
            for category in "${!tag_categories[@]}"; do
              if [[ "$file" == *"/tags/$category/"* ]]; then
                echo "  â„¹ï¸  ${tag_categories[$category]}: $file"
                break
              fi
            done

          done < <(find new_versions -path "*/tags/*/*.json" -type f -print0)

          echo ""
          echo "  Total tag files: $tag_count"

          if [ $error -eq 0 ]; then
            echo "âœ… Tag validation passed"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo "âŒ Tag validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # RECIPE VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Recipes
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”§ Validating Recipes..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          recipe_count=0
          error=0

          while IFS= read -r -d $'\0' file; do
            recipe_count=$((recipe_count + 1))
            
            # type field kontrolÃ¼
            if ! jq -e '.type' "$file" > /dev/null 2>&1; then
              echo "  âŒ Missing 'type' field in: $file"
              error=1
              continue
            fi

            recipe_type=$(jq -r '.type' "$file")
            
            # Recipe type validasyonu
            case "$recipe_type" in
              "minecraft:crafting_shaped"|"minecraft:crafting_shapeless"|"minecraft:smelting"|"minecraft:blasting"|"minecraft:smoking"|"minecraft:campfire_cooking"|"minecraft:stonecutting"|"minecraft:smithing_transform"|"minecraft:smithing_trim")
                echo "  âœ“ Valid recipe type: $recipe_type"
                ;;
              *)
                echo "  âš ï¸  Unknown recipe type: $recipe_type in $file"
                ;;
            esac

          done < <(find new_versions -path "*/recipe/*.json" -type f -print0)

          echo ""
          if [ $recipe_count -gt 0 ]; then
            echo "  Total recipes: $recipe_count"
            echo "âœ… Recipe validation passed"
          else
            echo "  No recipe files found (optional)"
          fi

          [ $error -ne 0 ] && exit 1

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FILE SIZE CHECK
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Check File Sizes
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Checking File Sizes..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          large_files=()
          
          while IFS= read -r -d $'\0' file; do
            size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
            
            # 1MB'dan bÃ¼yÃ¼k dosyalar iÃ§in uyarÄ±
            if [ $size -gt 1048576 ]; then
              size_mb=$(awk "BEGIN {printf \"%.2f\", $size/1048576}")
              echo "  âš ï¸  Large file ($size_mb MB): $file"
              large_files+=("$file")
            fi
          done < <(find new_versions -path "*/datapack/*" -type f -print0)

          if [ ${#large_files[@]} -gt 0 ]; then
            echo ""
            echo "âš ï¸  Found ${#large_files[@]} large file(s)"
          else
            echo "âœ… All files are reasonably sized"
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # GENERATE STRUCTURE TREE
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Generate Structure Tree
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸŒ³ Datapack Structure:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if command -v tree &> /dev/null; then
            tree -L 5 -I 'node_modules|.git' new_versions/ || true
          else
            find new_versions -type d -print | sed 's|[^/]*/| |g'
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FINAL SUMMARY
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validation Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ VALIDATION SUMMARY"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  Supported Pack Formats: 81, 88, 94"
          echo "  Invalid Pack Formats:   â‰¤80"
          echo ""
          echo "  JSON Files:       $(find new_versions -name '*.json' -type f 2>/dev/null | wc -l)"
          echo "  pack.mcmeta:      $(find new_versions -name 'pack.mcmeta' -type f 2>/dev/null | wc -l)"
          echo "  Functions:        $(find new_versions -name '*.mcfunction' -type f 2>/dev/null | wc -l)"
          echo "  Namespaces:       $(find new_versions -path '*/data/*' -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)"
          echo "  Tag Files:        $(find new_versions -path '*/tags/*/*.json' -type f 2>/dev/null | wc -l)"
          echo "  Recipes:          $(find new_versions -path '*/recipe/*.json' -type f 2>/dev/null | wc -l)"
          echo "  Advancements:     $(find new_versions -path '*/advancement/*.json' -type f 2>/dev/null | wc -l)"
          echo "  Loot Tables:      $(find new_versions -path '*/loot_table/*.json' -type f 2>/dev/null | wc -l)"
          echo "  Predicates:       $(find new_versions -path '*/predicate/*.json' -type f 2>/dev/null | wc -l)"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… ALL VALIDATIONS PASSED"
          else
            echo "âŒ VALIDATION FAILED - Please review errors above"
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # UPLOAD ARTIFACTS ON FAILURE
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Upload Validation Logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: validation-logs
          path: |
            new_versions/**/datapack/**/*.json
            new_versions/**/datapack/**/*.mcfunction
          retention-days: 7
