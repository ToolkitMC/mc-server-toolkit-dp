name: Validate Datapack

on:
  pull_request:
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  push:
    branches:
      - main
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  workflow_dispatch:

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq tree
          echo "âœ… Dependencies installed"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # JSON SYNTAX VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate JSON Syntax
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Validating JSON Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          count=0
          failed_files=()

          while IFS= read -r -d $'\0' file; do
            count=$((count + 1))
            echo "  Checking: $file"
            
            if ! jq empty "$file" 2>/dev/null; then
              echo "  âŒ Invalid JSON syntax: $file"
              failed_files+=("$file")
              error=1
            fi
          done < <(find new_versions -name "*.json" -type f -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… All $count JSON files are valid"
          else
            echo "âŒ Failed validation for ${#failed_files[@]} file(s):"
            printf '   - %s\n' "${failed_files[@]}"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FORBIDDEN METADATA CHECK
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Check Forbidden Auth Metadata
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”’ Checking Forbidden Metadata..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          violations=()

          # Check for ely.by metadata
          while IFS= read -r -d $'\0' file; do
            if jq -e '
              .. | objects |
              select(
                (.name? == "ely") and
                (.value? == "but why are you asking?")
              )
            ' "$file" > /dev/null 2>&1; then
              echo "  âŒ Forbidden ely.by metadata in: $file"
              violations+=("$file (ely.by)")
              error=1
            fi

            # Check for other suspicious auth patterns
            if jq -e '
              .. | objects |
              select(
                .authlib? or
                .authentication? or
                (.name? | test("auth|login|credential"; "i"))
              )
            ' "$file" > /dev/null 2>&1; then
              echo "  âš ï¸  Suspicious auth pattern in: $file"
            fi
          done < <(find new_versions -name "*.json" -type f -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… No forbidden metadata found"
          else
            echo "âŒ Found ${#violations[@]} violation(s)"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PACK.MCMETA VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate pack.mcmeta Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ Validating pack.mcmeta Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          found=0
          error=0
          warnings=0

          # GeÃ§erli pack format deÄŸerleri
          VALID_FORMATS=(81 88 94)
          INVALID_THRESHOLD=80

          # Pack format bilgilerini saklamak iÃ§in dizin oluÅŸtur
          mkdir -p /tmp/pack_formats

          while IFS= read -r -d $'\0' file; do
            found=1
            datapack_dir=$(dirname "$file")
            datapack_name=$(basename "$datapack_dir")
            
            echo "  Checking: $file"

            # Required: pack.pack_format
            if ! jq -e '.pack.pack_format' "$file" > /dev/null 2>&1; then
              echo "    âŒ Missing pack.pack_format"
              error=1
            else
              pack_format=$(jq -r '.pack.pack_format' "$file")
              echo "    â„¹ï¸  Pack format: $pack_format"
              
              # Pack format'Ä± dosyaya kaydet
              echo "$pack_format" > "/tmp/pack_formats/${datapack_name}.txt"
              
              # Pack format kontrolÃ¼
              is_valid=0
              for valid_format in "${VALID_FORMATS[@]}"; do
                if [ "$pack_format" -eq "$valid_format" ]; then
                  is_valid=1
                  break
                fi
              done

              if [ $is_valid -eq 1 ]; then
                case $pack_format in
                  81)
                    echo "    âœ… Valid pack format: 81"
                    ;;
                  88)
                    echo "    âœ… Valid pack format: 88"
                    ;;
                  94)
                    echo "    âœ… Valid pack format: 94"
                    ;;
                esac
              elif [ "$pack_format" -le "$INVALID_THRESHOLD" ]; then
                echo "    âŒ Invalid/Incompatible pack format: $pack_format (must be 81, 88, or 94)"
                error=1
              else
                echo "    âš ï¸  Unknown pack format: $pack_format (expected: 81, 88, or 94)"
                warnings=$((warnings + 1))
              fi
            fi

            # Required: pack.description
            if ! jq -e '.pack.description' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  Missing pack.description"
              warnings=$((warnings + 1))
            else
              description=$(jq -r '.pack.description' "$file")
              echo "    â„¹ï¸  Description: $description"
            fi

            # Check for supported_formats
            if jq -e '.pack.supported_formats' "$file" > /dev/null 2>&1; then
              supported=$(jq -r '.pack.supported_formats' "$file")
              echo "    â„¹ï¸  Supported formats: $supported"
            fi

            # Check for filter
            if jq -e '.filter' "$file" > /dev/null 2>&1; then
              block_count=$(jq '.filter.block | length' "$file" 2>/dev/null || echo 0)
              echo "    â„¹ï¸  Filter with $block_count block pattern(s)"
            fi

            # Check for overlays
            if jq -e '.overlays' "$file" > /dev/null 2>&1; then
              overlay_count=$(jq '.overlays.entries | length' "$file")
              echo "    â„¹ï¸  Has $overlay_count overlay(s)"
            fi

            echo ""
          done < <(find new_versions -name "pack.mcmeta" -type f -print0)

          if [ $found -eq 0 ]; then
            echo "âŒ No pack.mcmeta files found"
            exit 1
          fi

          if [ $error -eq 0 ]; then
            echo "âœ… All pack.mcmeta files are valid"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo "âŒ pack.mcmeta validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # DATAPACK STRUCTURE VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Datapack Structure
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Validating Datapack Structure..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          datapack_count=0

          while IFS= read -r -d $'\0' file; do
            dir=$(dirname "$file")
            datapack_count=$((datapack_count + 1))
            echo "  Datapack #$datapack_count: $dir"

            # Check for data/ directory
            if [ ! -d "$dir/data" ]; then
              echo "    âŒ Missing data/ directory"
              error=1
            else
              echo "    âœ… data/ directory exists"
              
              # Count namespaces
              namespace_count=$(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
              echo "    â„¹ï¸  Found $namespace_count namespace(s)"

              # List namespaces
              if [ $namespace_count -gt 0 ]; then
                while IFS= read -r namespace; do
                  ns_name=$(basename "$namespace")
                  echo "      â†’ $ns_name"
                  
                  # Standard directories
                  [ -d "$namespace/advancement" ] && echo "        âœ“ advancement/"
                  [ -d "$namespace/function" ] && echo "        âœ“ function/"
                  [ -d "$namespace/item_modifier" ] && echo "        âœ“ item_modifier/"
                  [ -d "$namespace/loot_table" ] && echo "        âœ“ loot_table/"
                  [ -d "$namespace/predicate" ] && echo "        âœ“ predicate/"
                  [ -d "$namespace/recipe" ] && echo "        âœ“ recipe/"
                  [ -d "$namespace/structure" ] && echo "        âœ“ structure/"
                  [ -d "$namespace/tags" ] && echo "        âœ“ tags/"
                  
                  # Worldgen directories
                  [ -d "$namespace/worldgen" ] && echo "        âœ“ worldgen/"
                  [ -d "$namespace/dimension" ] && echo "        âœ“ dimension/"
                  [ -d "$namespace/dimension_type" ] && echo "        âœ“ dimension_type/"
                  
                  # Additional directories
                  [ -d "$namespace/damage_type" ] && echo "        âœ“ damage_type/"
                  [ -d "$namespace/trim_material" ] && echo "        âœ“ trim_material/"
                  [ -d "$namespace/trim_pattern" ] && echo "        âœ“ trim_pattern/"
                  [ -d "$namespace/chat_type" ] && echo "        âœ“ chat_type/"
                  [ -d "$namespace/banner_pattern" ] && echo "        âœ“ banner_pattern/"
                  [ -d "$namespace/enchantment" ] && echo "        âœ“ enchantment/"
                  [ -d "$namespace/jukebox_song" ] && echo "        âœ“ jukebox_song/"
                  [ -d "$namespace/painting_variant" ] && echo "        âœ“ painting_variant/"
                  [ -d "$namespace/wolf_variant" ] && echo "        âœ“ wolf_variant/"
                  
                done < <(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)
              fi
            fi

            echo ""
          done < <(find new_versions -name "pack.mcmeta" -type f -print0)

          if [ $error -eq 0 ]; then
            echo "âœ… Datapack structure validation passed"
          else
            echo "âŒ Datapack structure validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MCFUNCTION FILES DETECTION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Detect Function Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Detecting .mcfunction Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          mcfunction_count=0
          
          while IFS= read -r -d $'\0' file; do
            mcfunction_count=$((mcfunction_count + 1))
            echo "  Found: $file"
          done < <(find new_versions -name "*.mcfunction" -type f -print0)
          
          echo ""
          echo "ğŸ“Š Total .mcfunction files found: $mcfunction_count"
          
          if [ $mcfunction_count -eq 0 ]; then
            echo "âš ï¸  No .mcfunction files detected in the datapack"
          else
            echo "âœ… .mcfunction files detected successfully"
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MCFUNCTION CONTENT VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Function Files Content
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âš™ï¸  Validating Function Files Content..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          warnings=0
          total_count=0
          total_lines=0
          total_commands=0

          # Komut uyumluluk matrisi
          declare -A command_min_format
          
          # TÃ¼m versiyonlarda geÃ§erli temel komutlar
          command_min_format["say"]=1
          command_min_format["tell"]=1
          command_min_format["tellraw"]=1
          command_min_format["msg"]=1
          command_min_format["me"]=1
          command_min_format["title"]=1
          command_min_format["subtitle"]=1
          command_min_format["actionbar"]=1
          command_min_format["help"]=1
          command_min_format["?"]=1
          
          # Oyun mekanik komutlarÄ±
          command_min_format["give"]=1
          command_min_format["clear"]=1
          command_min_format["summon"]=1
          command_min_format["kill"]=1
          command_min_format["tp"]=1
          command_min_format["teleport"]=1
          command_min_format["setblock"]=1
          command_min_format["fill"]=1
          command_min_format["clone"]=1
          command_min_format["execute"]=1
          command_min_format["particle"]=1
          command_min_format["playsound"]=1
          command_min_format["stopsound"]=1
          command_min_format["effect"]=1
          command_min_format["enchant"]=1
          command_min_format["xp"]=1
          command_min_format["experience"]=1
          
          # Scoreboard ve data komutlarÄ±
          command_min_format["scoreboard"]=1
          command_min_format["team"]=1
          command_min_format["tag"]=1
          command_min_format["data"]=1
          command_min_format["item"]=81
          
          # DÃ¼nya yÃ¶netimi
          command_min_format["gamemode"]=1
          command_min_format["difficulty"]=1
          command_min_format["weather"]=1
          command_min_format["time"]=1
          command_min_format["gamerule"]=1
          command_min_format["setworldspawn"]=1
          command_min_format["spawnpoint"]=1
          command_min_format["worldborder"]=1
          command_min_format["forceload"]=1
          command_min_format["seed"]=1
          command_min_format["spreadplayers"]=1
          
          # Function ve schedule
          command_min_format["function"]=1
          command_min_format["schedule"]=1
          command_min_format["datapack"]=1
          command_min_format["reload"]=1
          
          # GeliÅŸmiÅŸ komutlar
          command_min_format["advancement"]=1
          command_min_format["recipe"]=1
          command_min_format["loot"]=1
          command_min_format["attribute"]=1
          command_min_format["bossbar"]=1
          
          # Yeni komutlar (1.19.4+)
          command_min_format["damage"]=81
          command_min_format["ride"]=81
          command_min_format["fillbiome"]=81
          
          # Yeni komutlar (1.20+)
          command_min_format["return"]=81
          command_min_format["tick"]=81
          
          # Yeni komutlar (1.20.2+)
          command_min_format["random"]=81
          
          # Debug ve teknik
          command_min_format["debug"]=1
          command_min_format["locate"]=1
          command_min_format["locatebiome"]=1
          command_min_format["spectate"]=1
          
          # PvP ve sohbet
          command_min_format["kick"]=1
          command_min_format["ban"]=1
          command_min_format["ban-ip"]=1
          command_min_format["pardon"]=1
          command_min_format["pardon-ip"]=1
          command_min_format["op"]=1
          command_min_format["deop"]=1
          command_min_format["whitelist"]=1
          
          # Dialog (Ã¶zel/mod komutlarÄ± - her zaman izin ver)
          command_min_format["dialog"]=1
          
          # Deprecated komutlar
          declare -A deprecated_commands
          deprecated_commands["replaceitem"]="Use /item replace instead"

          while IFS= read -r -d $'\0' file; do
            total_count=$((total_count + 1))
            
            # Datapack adÄ±nÄ± bul
            datapack_path=$(echo "$file" | grep -o '.*/datapack' | head -1)
            if [ -n "$datapack_path" ]; then
              datapack_name=$(basename "$(dirname "$datapack_path")")
              pack_format_file="/tmp/pack_formats/${datapack_name}.txt"
              
              if [ -f "$pack_format_file" ]; then
                current_pack_format=$(cat "$pack_format_file")
              else
                current_pack_format=0
              fi
            else
              current_pack_format=0
            fi

            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            echo ""
            echo "  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  ğŸ“„ File: $relative_path"
            echo "  ğŸ“¦ Pack format: $current_pack_format"
            echo "  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            line_count=$(wc -l < "$file")
            total_lines=$((total_lines + line_count))

            # BoÅŸ dosya kontrolÃ¼
            if [ $line_count -eq 0 ]; then
              echo "    âš ï¸  Empty function file"
              warnings=$((warnings + 1))
              continue
            fi

            # Windows satÄ±r sonu kontrolÃ¼
            if grep -q $'\r' "$file"; then
              echo "    âŒ Windows line endings (CRLF) detected - use LF only"
              error=1
            fi

            # Tab karakteri kontrolÃ¼
            if grep -q $'\t' "$file"; then
              echo "    âš ï¸  Contains tab characters - use spaces instead"
              warnings=$((warnings + 1))
            fi

            # Makro kullanÄ±mÄ± kontrolÃ¼
            file_has_macro=0
            if grep -q '\$(' "$file"; then
              file_has_macro=1
            fi

            # Makro parametrelerini topla
            declare -A macro_params
            
            # SatÄ±r satÄ±r analiz
            line_num=0
            file_commands=0
            
            while IFS= read -r line; do
              line_num=$((line_num + 1))
              
              # BoÅŸ satÄ±r ve yorum kontrolÃ¼
              [[ "$line" =~ ^[[:space:]]*$ ]] && continue
              [[ "$line" =~ ^[[:space:]]*# ]] && continue

              file_commands=$((file_commands + 1))
              total_commands=$((total_commands + 1))

              # SatÄ±rÄ± temizle ve komutu Ã§Ä±kar
              clean_line=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              
              # Slash ile baÅŸlÄ±yorsa kaldÄ±r
              if [[ "$clean_line" =~ ^/ ]]; then
                clean_line="${clean_line:1}"
              fi
              
              # Komut adÄ±nÄ± al (ilk kelime)
              cmd=$(echo "$clean_line" | cut -d' ' -f1)

              # Deprecated komut kontrolÃ¼
              if [ -n "${deprecated_commands[$cmd]}" ]; then
                echo "    âŒ Line $line_num: Deprecated command '/$cmd'"
                echo "       â†’ ${deprecated_commands[$cmd]}"
                error=1
                continue
              fi

              # Komut uyumluluk kontrolÃ¼
              if [ -n "${command_min_format[$cmd]}" ]; then
                required_format="${command_min_format[$cmd]}"
                
                if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt "$required_format" ]; then
                  echo "    âŒ Line $line_num: Command '/$cmd' requires pack_format $required_format+"
                  echo "       Current pack_format: $current_pack_format"
                  error=1
                fi
              else
                # Bilinmeyen komut - uyarÄ± ver ama hata verme (mod/plugin komutlarÄ± iÃ§in)
                if [[ ! "$cmd" =~ ^(minecraft:|#) ]]; then
                  echo "    â„¹ï¸  Line $line_num: Custom/unknown command '/$cmd' (may be from mod/plugin)"
                fi
              fi

              # Execute subcommand kontrolÃ¼
              if [[ "$clean_line" =~ ^execute ]]; then
                # if/unless biome
                if [[ "$clean_line" =~ (if|unless)[[:space:]]+biome ]]; then
                  if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                    echo "    âŒ Line $line_num: 'execute if/unless biome' requires pack_format 81+"
                    error=1
                  fi
                fi
                
                # if/unless dimension
                if [[ "$clean_line" =~ (if|unless)[[:space:]]+dimension ]]; then
                  if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                    echo "    âŒ Line $line_num: 'execute if/unless dimension' requires pack_format 81+"
                    error=1
                  fi
                fi
                
                # on relation
                if [[ "$clean_line" =~ execute[[:space:]]+on[[:space:]] ]]; then
                  if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                    echo "    âŒ Line $line_num: 'execute on <relation>' requires pack_format 81+"
                    error=1
                  fi
                fi

                # summon
                if [[ "$clean_line" =~ execute[[:space:]]+summon ]]; then
                  if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                    echo "    â„¹ï¸  Line $line_num: 'execute summon' available in pack_format 81+"
                  fi
                fi
              fi

              # Makro deÄŸiÅŸken kullanÄ±mÄ± kontrolÃ¼ - $(variable)
              if [[ "$clean_line" =~ \$\( ]]; then
                # Pack format kontrolÃ¼
                if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: Macros \$(variable) require pack_format 81+"
                  error=1
                else
                  # Makro deÄŸiÅŸkenlerini Ã§Ä±kar
                  while [[ "$clean_line" =~ \$\(([a-zA-Z0-9_]+)\) ]]; do
                    var_name="${BASH_REMATCH[1]}"
                    macro_params["$var_name"]=1
                    echo "    âœ“ Line $line_num: Uses macro variable: \$(${var_name})"
                    # Sonraki eÅŸleÅŸmeyi bulmak iÃ§in satÄ±rdan kaldÄ±r
                    clean_line="${clean_line/${BASH_REMATCH[0]}/}"
                  done
                fi
              fi

              # ÅÃ¼pheli pattern kontrolÃ¼
              if [[ "$clean_line" =~ execute.*run.*execute.*run.*execute ]]; then
                echo "    âš ï¸  Line $line_num: Very complex execute chain (3+ levels)"
                warnings=$((warnings + 1))
              fi

              # Path traversal kontrolÃ¼
              if [[ "$clean_line" =~ \.\. ]]; then
                echo "    âŒ Line $line_num: Path traversal (..) is not allowed"
                error=1
              fi

            done < "$file"

            # Makro sistemi sonuÃ§ kontrolÃ¼
            echo ""
            if [ $file_has_macro -eq 1 ]; then
              # $ var ama $() yok - HATA
              if [ ${#macro_params[@]} -eq 0 ]; then
                echo "    âŒ MACRO ERROR: File contains $ but no \$(variable) syntax found"
                echo "       â†’ Macros must use \$(variable) format (requires pack_format 81+)"
                error=1
              else
                # $() var ve deÄŸiÅŸkenler bulundu - BAÅARI
                echo "    âœ… MACRO SUCCESS: Found ${#macro_params[@]} macro variable(s)"
                echo "       Variables used: ${!macro_params[*]}"
                
                # DeÄŸiÅŸken tanÄ±mlamasÄ± var mÄ± kontrol et
                # Not: .mcfunction dosyasÄ±nda deÄŸiÅŸken tanÄ±mÄ± olmaz, bunlar Ã§aÄŸrÄ± sÄ±rasÄ±nda verilir
                # Sadece kullanÄ±mÄ± tespit ediyoruz
              fi
            else
              # Ne $ ne de $() var - makro kullanÄ±lmamÄ±ÅŸ, sorun yok
              echo "    â„¹ï¸  No macro variables used in this file"
            fi

            echo "    âœ“ Analyzed $file_commands command(s) in $line_count line(s)"

          done < <(find new_versions -name "*.mcfunction" -type f -print0)

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Function Analysis Summary:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Total files:     $total_count"
          echo "  Total lines:     $total_lines"
          echo "  Total commands:  $total_commands"
          [ $total_count -gt 0 ] && echo "  Avg lines/file:  $((total_lines / total_count))"
          [ $total_count -gt 0 ] && echo "  Avg cmds/file:   $((total_commands / total_count))"

          if [ $error -eq 0 ]; then
            echo ""
            echo "âœ… Function content validation passed"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo ""
            echo "âŒ Function content validation failed"
            echo "   Please fix the errors above"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MACRO SYSTEM VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Macro System
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”§ Validating Macro System..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          warnings=0
          files_with_macros=0
          files_with_dollar_only=0
          total_macro_vars=0

          while IFS= read -r -d $'\0' file; do
            
            # Datapack pack format kontrolÃ¼
            datapack_path=$(echo "$file" | grep -o '.*/datapack' | head -1)
            if [ -n "$datapack_path" ]; then
              datapack_name=$(basename "$(dirname "$datapack_path")")
              pack_format_file="/tmp/pack_formats/${datapack_name}.txt"
              
              if [ -f "$pack_format_file" ]; then
                current_pack_format=$(cat "$pack_format_file")
              else
                current_pack_format=0
              fi
            else
              current_pack_format=0
            fi

            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            
            # $ karakteri var mÄ±?
            has_dollar=$(grep -c '\$' "$file" 2>/dev/null || echo 0)
            
            # $() syntax var mÄ±?
            has_macro=$(grep -c '\$(' "$file" 2>/dev/null || echo 0)
            
            if [ $has_dollar -gt 0 ]; then
              if [ $has_macro -gt 0 ]; then
                # âœ… $() var - BAÅARI
                files_with_macros=$((files_with_macros + 1))
                
                # DeÄŸiÅŸken adlarÄ±nÄ± Ã§Ä±kar
                vars=$(grep -oP '\$\(\K[a-zA-Z0-9_]+(?=\))' "$file" | sort -u)
                var_count=$(echo "$vars" | wc -l)
                total_macro_vars=$((total_macro_vars + var_count))
                
                echo "  âœ… $relative_path"
                echo "     â†’ Pack format: $current_pack_format"
                echo "     â†’ Macro variables ($var_count): $(echo $vars | tr '\n' ', ' | sed 's/, $//')"
                
              else
                # âŒ $ var ama $() yok - HATA
                files_with_dollar_only=$((files_with_dollar_only + 1))
                echo "  âŒ $relative_path"
                echo "     â†’ ERROR: Contains $ character but no valid \$(variable) syntax"
                echo "     â†’ Macros must use \$(variable) format"
                echo "     â†’ Pack format: $current_pack_format (requires 81+ for macros)"
                
                # $ kullanÄ±mlarÄ±nÄ± gÃ¶ster
                echo "     â†’ Found $ in lines:"
                grep -n '\$' "$file" | head -5 | while read -r line; do
                  echo "        $(echo "$line" | cut -c1-80)"
                done
                
                error=1
              fi
            fi

          done < <(find new_versions -name "*.mcfunction" -type f -print0)

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Macro System Summary:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Files with valid macros:   $files_with_macros"
          echo "  Files with invalid $ use:  $files_with_dollar_only"
          echo "  Total macro variables:     $total_macro_vars"
          echo ""
          
          if [ $files_with_macros -gt 0 ]; then
            echo "  â„¹ï¸  Macro Usage Information:"
            echo "     â†’ Macros require pack_format 81+ (MC 1.20.2+)"
            echo "     â†’ Use \$(variable_name) syntax"
            echo "     â†’ Variables are passed when calling the function"
            echo "     â†’ Example: function namespace:path {variable_name: value}"
          fi

          if [ $error -eq 0 ]; then
            echo ""
            if [ $files_with_macros -eq 0 ]; then
              echo "â„¹ï¸  No macro system usage detected"
            else
              echo "âœ… Macro system validation passed"
            fi
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo ""
            echo "âŒ Macro system validation failed"
            echo ""
            echo "Common issues:"
            echo "  â€¢ Using $ without \$(variable) syntax"
            echo "  â€¢ Incorrect macro format"
            echo "  â€¢ Pack format must be 81+ for macro support"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # NAMESPACE VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Namespaces
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ·ï¸  Validating Namespaces..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          namespace_count=0
          
          while IFS= read -r -d $'\0' namespace; do
            namespace_count=$((namespace_count + 1))
            ns_name=$(basename "$namespace")
            echo "  [$namespace_count] Namespace: $ns_name"

            # Namespace isimlendirme kuralÄ±
            if ! [[ "$ns_name" =~ ^[a-z0-9_.-]+$ ]]; then
              echo "      âŒ Invalid name (use: a-z, 0-9, _, ., - only)"
              error=1
            else
              echo "      âœ“ Valid naming"
            fi

            # minecraft namespace kontrolÃ¼
            if [ "$ns_name" = "minecraft" ]; then
              echo "      âš ï¸  Reserved 'minecraft' namespace (not recommended)"
            fi

            # Uzunluk kontrolÃ¼
            if [ ${#ns_name} -gt 255 ]; then
              echo "      âŒ Name too long (max: 255 chars, current: ${#ns_name})"
              error=1
            fi

          done < <(find new_versions -path "*/data/*" -mindepth 1 -maxdepth 1 -type d -print0)

          echo ""
          echo "  Total namespaces found: $namespace_count"
          
          if [ $error -eq 0 ]; then
            echo "âœ… Namespace validation passed"
          else
            echo "âŒ Namespace validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # TAG FILES VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Tag Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ·ï¸  Validating Tag Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          tag_count=0
          error=0
          warnings=0

          while IFS= read -r -d $'\0' file; do
            tag_count=$((tag_count + 1))
            
            # Tag yapÄ±sÄ± kontrolÃ¼
            if ! jq -e '.values' "$file" > /dev/null 2>&1; then
              echo "  âŒ Missing 'values' array in: $file"
              error=1
              continue
            fi

            # values sayÄ±sÄ±
            values_count=$(jq '.values | length' "$file")
            if [ "$values_count" -eq 0 ]; then
              echo "  âš ï¸  Empty values in: $file"
              warnings=$((warnings + 1))
            fi

          done < <(find new_versions -path "*/tags/*/*.json" -type f -print0)

          echo ""
          echo "  Total tag files: $tag_count"

          if [ $error -eq 0 ]; then
            echo "âœ… Tag validation passed"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) found"
          else
            echo "âŒ Tag validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FILE SIZE CHECK
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Check File Sizes
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Checking File Sizes..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          large_files=()
          
          while IFS= read -r -d $'\0' file; do
            size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
            
            if [ $size -gt 1048576 ]; then
              size_mb=$(awk "BEGIN {printf \"%.2f\", $size/1048576}")
              echo "  âš ï¸  Large file ($size_mb MB): $file"
              large_files+=("$file")
            fi
          done < <(find new_versions -path "*/datapack/*" -type f -print0)

          if [ ${#large_files[@]} -gt 0 ]; then
            echo ""
            echo "âš ï¸  Found ${#large_files[@]} large file(s)"
          else
            echo "âœ… All files are reasonably sized"
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # GENERATE STRUCTURE TREE
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Generate Structure Tree
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸŒ³ Datapack Structure:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if command -v tree &> /dev/null; then
            tree -L 5 -I 'node_modules|.git' new_versions/ 2>/dev/null || find new_versions -type d -print | sed 's|[^/]*/| |g'
          else
            find new_versions -type d -print | sed 's|[^/]*/| |g'
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FINAL SUMMARY
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validation Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ VALIDATION SUMMARY"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  âœ… Valid Pack Formats:   81, 88, 94"
          echo "  âŒ Invalid Pack Formats: â‰¤80"
          echo ""
          echo "  ğŸ“¦ pack.mcmeta:      $(find new_versions -name 'pack.mcmeta' -type f 2>/dev/null | wc -l)"
          echo "  ğŸ“„ JSON Files:       $(find new_versions -name '*.json' -type f 2>/dev/null | wc -l)"
          echo "  âš™ï¸  Functions:        $(find new_versions -name '*.mcfunction' -type f 2>/dev/null | wc -l)"
          echo "  ğŸ·ï¸  Namespaces:       $(find new_versions -path '*/data/*' -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)"
          echo "  ğŸ”– Tag Files:        $(find new_versions -path '*/tags/*/*.json' -type f 2>/dev/null | wc -l)"
          echo "  ğŸ”§ Recipes:          $(find new_versions -path '*/recipe/*.json' -type f 2>/dev/null | wc -l)"
          echo "  ğŸ† Advancements:     $(find new_versions -path '*/advancement/*.json' -type f 2>/dev/null | wc -l)"
          echo "  ğŸ“¦ Loot Tables:      $(find new_versions -path '*/loot_table/*.json' -type f 2>/dev/null | wc -l)"
          echo ""
          echo "  ğŸ”§ Macro System:"
          echo "     Files with macros: $(find new_versions -name '*.mcfunction' -type f -exec grep -l '\$(' {} \; 2>/dev/null | wc -l)"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… ALL VALIDATIONS PASSED"
            echo ""
            echo "Your datapack is ready for deployment! ğŸš€"
          else
            echo "âŒ VALIDATION FAILED"
            echo ""
            echo "Please review the errors above and fix them."
            echo "Common issues:"
            echo "  â€¢ Invalid pack_format (must be 81, 88, or 94)"
            echo "  â€¢ Commands not compatible with pack_format"
            echo "  â€¢ Invalid JSON syntax"
            echo "  â€¢ Missing required files"
            echo "  â€¢ Invalid macro syntax (use \$(variable) format)"
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # UPLOAD ARTIFACTS ON FAILURE
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Upload Validation Logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: validation-logs
          path: |
            new_versions/**/datapack/**/*.json
            new_versions/**/datapack/**/*.mcfunction
          retention-days: 7
